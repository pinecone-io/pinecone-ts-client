/* tslint:disable */
/* eslint-disable */
/**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: unstable
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * The embedding model and document fields mapped to embedding inputs.
 * @export
 * @interface ModelIndexEmbed
 */
export interface ModelIndexEmbed {
    /**
     * The name of the embedding model used to create the index.
     * @type {string}
     * @memberof ModelIndexEmbed
     */
    model: string;
    /**
     * The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
     * @type {string}
     * @memberof ModelIndexEmbed
     */
    metric?: ModelIndexEmbedMetricEnum;
    /**
     * The dimensions of the vectors to be inserted in the index.
     * @type {number}
     * @memberof ModelIndexEmbed
     */
    dimension?: number;
    /**
     * The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
     * @type {string}
     * @memberof ModelIndexEmbed
     */
    vectorType?: string;
    /**
     * Identifies the name of the text field from your document model that is embedded.
     * @type {object}
     * @memberof ModelIndexEmbed
     */
    fieldMap?: object;
    /**
     * The read parameters for the embedding model.
     * @type {object}
     * @memberof ModelIndexEmbed
     */
    readParameters?: object;
    /**
     * The write parameters for the embedding model.
     * @type {object}
     * @memberof ModelIndexEmbed
     */
    writeParameters?: object;
}


/**
 * @export
 */
export const ModelIndexEmbedMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
} as const;
export type ModelIndexEmbedMetricEnum = typeof ModelIndexEmbedMetricEnum[keyof typeof ModelIndexEmbedMetricEnum];


/**
 * Check if a given object implements the ModelIndexEmbed interface.
 */
export function instanceOfModelIndexEmbed(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "model" in value;

    return isInstance;
}

export function ModelIndexEmbedFromJSON(json: any): ModelIndexEmbed {
    return ModelIndexEmbedFromJSONTyped(json, false);
}

export function ModelIndexEmbedFromJSONTyped(json: any, ignoreDiscriminator: boolean): ModelIndexEmbed {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'model': json['model'],
        'metric': !exists(json, 'metric') ? undefined : json['metric'],
        'dimension': !exists(json, 'dimension') ? undefined : json['dimension'],
        'vectorType': !exists(json, 'vector_type') ? undefined : json['vector_type'],
        'fieldMap': !exists(json, 'field_map') ? undefined : json['field_map'],
        'readParameters': !exists(json, 'read_parameters') ? undefined : json['read_parameters'],
        'writeParameters': !exists(json, 'write_parameters') ? undefined : json['write_parameters'],
    };
}

export function ModelIndexEmbedToJSON(value?: ModelIndexEmbed | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'model': value.model,
        'metric': value.metric,
        'dimension': value.dimension,
        'vector_type': value.vectorType,
        'field_map': value.fieldMap,
        'read_parameters': value.readParameters,
        'write_parameters': value.writeParameters,
    };
}

