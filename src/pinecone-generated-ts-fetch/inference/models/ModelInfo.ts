/* tslint:disable */
/* eslint-disable */
/**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { ModelInfoMetric } from './ModelInfoMetric';
import {
    ModelInfoMetricFromJSON,
    ModelInfoMetricFromJSONTyped,
    ModelInfoMetricToJSON,
} from './ModelInfoMetric';
import type { ModelInfoSupportedParameter } from './ModelInfoSupportedParameter';
import {
    ModelInfoSupportedParameterFromJSON,
    ModelInfoSupportedParameterFromJSONTyped,
    ModelInfoSupportedParameterToJSON,
} from './ModelInfoSupportedParameter';

/**
 * Represents the model configuration including model type, supported parameters, and other model details.
 * @export
 * @interface ModelInfo
 */
export interface ModelInfo {
    /**
     * The name of the model.
     * @type {string}
     * @memberof ModelInfo
     */
    model: string;
    /**
     * A summary of the model.
     * @type {string}
     * @memberof ModelInfo
     */
    shortDescription: string;
    /**
     * The type of model (e.g. 'embed' or 'rerank').
     * @type {string}
     * @memberof ModelInfo
     */
    type: ModelInfoTypeEnum;
    /**
     * Whether the embedding model produces 'dense' or 'sparse' embeddings.
     * @type {string}
     * @memberof ModelInfo
     */
    vectorType?: ModelInfoVectorTypeEnum;
    /**
     * The default embedding model dimension (applies to dense embedding models only).
     * @type {number}
     * @memberof ModelInfo
     */
    defaultDimension?: number;
    /**
     * The modality of the model (e.g. 'text').
     * @type {string}
     * @memberof ModelInfo
     */
    modality?: string;
    /**
     * The maximum tokens per sequence supported by the model.
     * @type {number}
     * @memberof ModelInfo
     */
    maxSequenceLength?: number;
    /**
     * The maximum batch size (number of sequences) supported by the model.
     * @type {number}
     * @memberof ModelInfo
     */
    maxBatchSize?: number;
    /**
     * The name of the provider of the model.
     * @type {string}
     * @memberof ModelInfo
     */
    providerName?: string;
    /**
     * The list of supported dimensions for the model (applies to dense embedding models only).
     * @type {Array<number>}
     * @memberof ModelInfo
     */
    supportedDimensions?: Array<number>;
    /**
     * The distance metrics supported by the model for similarity search.
     * @type {Array<ModelInfoMetric>}
     * @memberof ModelInfo
     */
    supportedMetrics?: Array<ModelInfoMetric>;
    /**
     * 
     * @type {Array<ModelInfoSupportedParameter>}
     * @memberof ModelInfo
     */
    supportedParameters: Array<ModelInfoSupportedParameter>;
}


/**
 * @export
 */
export const ModelInfoTypeEnum = {
    Embed: 'embed',
    Rerank: 'rerank'
} as const;
export type ModelInfoTypeEnum = typeof ModelInfoTypeEnum[keyof typeof ModelInfoTypeEnum];

/**
 * @export
 */
export const ModelInfoVectorTypeEnum = {
    Dense: 'dense',
    Sparse: 'sparse'
} as const;
export type ModelInfoVectorTypeEnum = typeof ModelInfoVectorTypeEnum[keyof typeof ModelInfoVectorTypeEnum];


/**
 * Check if a given object implements the ModelInfo interface.
 */
export function instanceOfModelInfo(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "shortDescription" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "supportedParameters" in value;

    return isInstance;
}

export function ModelInfoFromJSON(json: any): ModelInfo {
    return ModelInfoFromJSONTyped(json, false);
}

export function ModelInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): ModelInfo {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'model': json['model'],
        'shortDescription': json['short_description'],
        'type': json['type'],
        'vectorType': !exists(json, 'vector_type') ? undefined : json['vector_type'],
        'defaultDimension': !exists(json, 'default_dimension') ? undefined : json['default_dimension'],
        'modality': !exists(json, 'modality') ? undefined : json['modality'],
        'maxSequenceLength': !exists(json, 'max_sequence_length') ? undefined : json['max_sequence_length'],
        'maxBatchSize': !exists(json, 'max_batch_size') ? undefined : json['max_batch_size'],
        'providerName': !exists(json, 'provider_name') ? undefined : json['provider_name'],
        'supportedDimensions': !exists(json, 'supported_dimensions') ? undefined : json['supported_dimensions'],
        'supportedMetrics': !exists(json, 'supported_metrics') ? undefined : ((json['supported_metrics'] as Array<any>).map(ModelInfoMetricFromJSON)),
        'supportedParameters': ((json['supported_parameters'] as Array<any>).map(ModelInfoSupportedParameterFromJSON)),
    };
}

export function ModelInfoToJSON(value?: ModelInfo | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'model': value.model,
        'short_description': value.shortDescription,
        'type': value.type,
        'vector_type': value.vectorType,
        'default_dimension': value.defaultDimension,
        'modality': value.modality,
        'max_sequence_length': value.maxSequenceLength,
        'max_batch_size': value.maxBatchSize,
        'provider_name': value.providerName,
        'supported_dimensions': value.supportedDimensions,
        'supported_metrics': value.supportedMetrics === undefined ? undefined : ((value.supportedMetrics as Array<any>).map(ModelInfoMetricToJSON)),
        'supported_parameters': ((value.supportedParameters as Array<any>).map(ModelInfoSupportedParameterToJSON)),
    };
}

